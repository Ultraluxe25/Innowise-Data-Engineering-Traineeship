<h1 align="center">Different underhood stuff</h1>


## Description

Здесь вы узнаете про различные темы, которые не столь важны(на самом деле они очень сильно влияют на производительность, зато менеджить их в разы труднее), 
но упомянуть их я просто не могу, ибо иногда их могут спросить на собесах(на очень жестких собесах).


## Spill эффект

Статья: https://selectfrom.dev/spark-performance-tuning-spill-7318363e18cb.

## Garbage collection and Serialization

Вам нужны два топика из следующей статьи(Data Serialization и Garbage Collection Tuning):https://spark.apache.org/docs/latest/tuning.html.

## Tungsten

Короче, тут на самом деле никто сам до конца не знает(кроме разрабов конечно) что вообще эта штука делает в полной мере(если что это слова одного дата инженера у которого
опыт больше чем 10 лет из которых как только появился хадуп он начал работать с ним и всем что с ним связано). Так вот, разработчики этой штуки гении и сейчас вы поймете 
почему. Начнём с простого: Java объекты очень большие. Строка abcd занимает всего 4 байта с использованием собственной кодировки UTF-8, а Java-объект с этими данными 
будет весить уже 48 байтов, включая заголовок объекта, хэш-код, служебные данные и символы. Вот так прикол да. Вызовы виртуальных функция(или как там это в джаве) тоже
очень тяжелые. Тут на помощь и приходит Tungsten. Его разработчики очень шарят в железе, поэтому Tungsten работает напрямую с бинаркой. Условно говоря вам надо сделать
A+B, и в джаве это значит надо взять объект A потом объект B вызвать виртуальную функцию(или как она там), там произвести вычесления внутри неё и только потом вернуть
ответ. Tungsten же говорит что A+B это всего лишь A+B и ничего там вызывать не надо(если это конечно примитивные типы, взять тот же int). Он просто говорит что взять
бинарку A, взять бинарку B и сделать то и то, при чём используя алгоритмы которые используют все преимущества кэша(алгоритмы близки к железу). Поэтому иногда, в конце
плана оптимизитора можно увидеть Tungsten отдельным блоком, ибо так оно и есть. Tungsten переведёт весь в код в машинный, при чём подбирая те алгоритмы, которые наиболее
выгодны и быстры. Думаю вы помните off-heap memory. Сохраните датафрейм в обычной памяти(функция cache) и он будет весить
много. Сохраните его в off-heap и он будет весить в разы меньше. Вообще как вы читали те же string объкты активно сохраняются и обрабатываются в off-heap.
Также, Tungsten shuffle утирает нос другим shuffle стратегиям(вы о них всех читали). Как раз таки потому, что если вы помните когда буфферу(не важно read buffer или write buffer)
не хватает памяти он скидывает инфу на диск. И тут как вы понимаете, данные сериализуюся чтобы быть записаными на диск. Потом их надо будет десериализовать, отсортировать, 
объединить и снова сериализовать и записать на диск снова перед отправкой. Так вот Tungsten умеет сортировать бинарку, а это значит что никакой десериализации не будет, он просто 
возьмёт все файлы на диске, отсортирует их вместе, и так и оставит в сериализованном виде. Думаете это не важно? Это очень важно т.к. процесс сериализации и десериализации
очень тяжелый. Подводя итог: преобразует физический план в набор инструкций для машины; умеет работать напрямую с бинаркой, что позволяет экономить
на циклах сериализации и десериализации; объекты tungsten в разы меньше весят чем Java.
Вот статья про tungsten project которую теперь должно быть не так трудно понять после моего вводного(надеюсь): 
https://www.databricks.com/blog/2015/04/28/project-tungsten-bringing-spark-closer-to-bare-metal.html.

